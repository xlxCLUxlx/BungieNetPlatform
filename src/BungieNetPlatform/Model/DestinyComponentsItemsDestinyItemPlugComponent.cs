/* 
 * Bungie.Net API
 *
 * These endpoints constitute the functionality exposed by Bungie.net, both for more traditional website functionality and for connectivity to Bungie video games and their related functionality.
 *
 * OpenAPI spec version: 2.1.1
 * Contact: support@bungie.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using System.ComponentModel.DataAnnotations;
using SwaggerDateConverter = BungieNetPlatform.Client.SwaggerDateConverter;

namespace BungieNetPlatform.Model
{
    /// <summary>
    /// Plugs are non-instanced items that can provide Stat and Perk benefits when socketed into an instanced item. Items have Sockets, and Plugs are inserted into Sockets.  This component finds all items that are considered \&quot;Plugs\&quot; in your inventory, and return information about the plug aside from any specific Socket into which it could be inserted.
    /// </summary>
    [DataContract]
    public partial class DestinyComponentsItemsDestinyItemPlugComponent :  IEquatable<DestinyComponentsItemsDestinyItemPlugComponent>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="DestinyComponentsItemsDestinyItemPlugComponent" /> class.
        /// </summary>
        /// <param name="InsertFailIndexes">If the plug cannot be inserted for some reason, this will have the indexes into the plug item definition&#39;s plug.insertionRules property, so you can show the reasons why it can&#39;t be inserted.  This list will be empty if the plug can be inserted..</param>
        /// <param name="EnableFailIndexes">If a plug is not enabled, this will be populated with indexes into the plug item definition&#39;s plug.enabledRules property, so that you can show the reasons why it is not enabled.  This list will be empty if the plug is enabled..</param>
        public DestinyComponentsItemsDestinyItemPlugComponent(List<int?> InsertFailIndexes = default(List<int?>), List<int?> EnableFailIndexes = default(List<int?>))
        {
            this.InsertFailIndexes = InsertFailIndexes;
            this.EnableFailIndexes = EnableFailIndexes;
        }
        
        /// <summary>
        /// If the plug cannot be inserted for some reason, this will have the indexes into the plug item definition&#39;s plug.insertionRules property, so you can show the reasons why it can&#39;t be inserted.  This list will be empty if the plug can be inserted.
        /// </summary>
        /// <value>If the plug cannot be inserted for some reason, this will have the indexes into the plug item definition&#39;s plug.insertionRules property, so you can show the reasons why it can&#39;t be inserted.  This list will be empty if the plug can be inserted.</value>
        [DataMember(Name="insertFailIndexes", EmitDefaultValue=false)]
        public List<int?> InsertFailIndexes { get; set; }

        /// <summary>
        /// If a plug is not enabled, this will be populated with indexes into the plug item definition&#39;s plug.enabledRules property, so that you can show the reasons why it is not enabled.  This list will be empty if the plug is enabled.
        /// </summary>
        /// <value>If a plug is not enabled, this will be populated with indexes into the plug item definition&#39;s plug.enabledRules property, so that you can show the reasons why it is not enabled.  This list will be empty if the plug is enabled.</value>
        [DataMember(Name="enableFailIndexes", EmitDefaultValue=false)]
        public List<int?> EnableFailIndexes { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class DestinyComponentsItemsDestinyItemPlugComponent {\n");
            sb.Append("  InsertFailIndexes: ").Append(InsertFailIndexes).Append("\n");
            sb.Append("  EnableFailIndexes: ").Append(EnableFailIndexes).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
  
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as DestinyComponentsItemsDestinyItemPlugComponent);
        }

        /// <summary>
        /// Returns true if DestinyComponentsItemsDestinyItemPlugComponent instances are equal
        /// </summary>
        /// <param name="input">Instance of DestinyComponentsItemsDestinyItemPlugComponent to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(DestinyComponentsItemsDestinyItemPlugComponent input)
        {
            if (input == null)
                return false;

            return 
                (
                    this.InsertFailIndexes == input.InsertFailIndexes ||
                    this.InsertFailIndexes != null &&
                    this.InsertFailIndexes.SequenceEqual(input.InsertFailIndexes)
                ) && 
                (
                    this.EnableFailIndexes == input.EnableFailIndexes ||
                    this.EnableFailIndexes != null &&
                    this.EnableFailIndexes.SequenceEqual(input.EnableFailIndexes)
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.InsertFailIndexes != null)
                    hashCode = hashCode * 59 + this.InsertFailIndexes.GetHashCode();
                if (this.EnableFailIndexes != null)
                    hashCode = hashCode * 59 + this.EnableFailIndexes.GetHashCode();
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

}
